{"./":{"url":"./","title":"1. 简介","keywords":"","body":"基于龙芯FPGA开发板的计算机系统综合实验 为了加强大学本科计算机专业的专业基础课知识的掌握和综合运用，以已有的“计算机系统综合实验”为基础，完善形成本实验手册。这个计算机系统综合实验的目的是，综合运用“汇编语言”、“计算机组成原理”、‘’操作系统‘和”编译原理“等课程的知识，设计和实现一个简单但功能完善的计算机系统。 计算机系统综合实验的目标如下： 实现一个可运行龙芯FPGA实验板上的MIPS32S CPU（也可以直接使用龙芯的开源MIPS32 CPU），并支持串口、键盘、鼠标、VGA等简单外设； 移植教学操作系统ucore到MIPS32S CPU上； 在ubuntu 16.04上实现一个交叉编译器，可以把符合C0的应用程序编译成MIPS32S上的应用程序，并在ucore上运行； 进行其他可能的功能扩展。如，支持网络和调试工具等。 相关参考信息链接： wiki gitbook github repo const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"cpu/实验箱介绍.html":{"url":"cpu/实验箱介绍.html","title":"1.1龙芯实验箱介绍","keywords":"","body":"龙芯系统能力培养大赛实验箱 1. 清单 FPGA开发板 1个 XILINX USB下载器及下载线 1个 5V/2A 电源适配器 1个 10芯排线 2个 6芯排线 2个 2. 板载资源 FPGA Artix-7A200T-FBG676 DDR3 1GB 板载K4B1G1646G-BCK0 DDR3颗粒 SRAM 板载IDT71V124SATY SRAM芯片 NAND 板载K9F1G08U0C-PCB0 闪存颗粒 SPI Flash 1 板载可插拔芯片 SPI Flash 2 板载不可插拔芯片 VGA 板载MM74HC573SJ 实现332 数模转换 LCD 板载TFT-LCD屏 USB 板载USB PHY(USB3500)接口 LAN 板载以太网 PHY(DM9161AEP)网络接口 PS2 板载PS2接口 UART 板载UART接口 GPIO 16个LED单色灯、 2个LED双色灯、8×8 LED点阵（字符显示）、8个共阴级八段数码管（数字显示） const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"cpu/实验箱测试.html":{"url":"cpu/实验箱测试.html","title":"1.2实验箱测试流程","keywords":"","body":"GPIO测试 将竞赛资源包 目录nscscc_20170731\\FPGA_test_v1.00\\FPGA_gpio_test 下的FPGA_green_test.bit 至FPGA 中。 测试项 包括：单色LED灯、双色LED灯、数码管、点阵、LCD触摸屏、复位键、拨码开关、按钮开关、矩阵键盘。 测试结果 a. 16个单色LED灯 与 4x4矩阵键盘上的16个按键 对应，按一个亮一个； b. 双色LED灯 与 两个按钮开关中的上方那个 对应，按一下变色； c. 8个数码管 与 8个拨码开关对应，拨上则亮，且每个数码管会从0扫描显示到9； d. 点阵 不停地自己刷新每一列每一行； e. LCD触摸屏 与 按钮开关下方按钮 配合，显示单周期CPU的状态，按钮开关充当 时钟，主要触摸屏的功能也要测试； f. 复位键 用于复位全局。 const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"cpu/":{"url":"cpu/","title":"2. 基于FPGA的MIPS32SCPU实现","keywords":"","body":"基于FPGA的MIPS32SCPU实现 为了方便在龙芯FPGA开发板了完成一个MIPS32S CPU的实现工作，我们在这里首先讨论Vivado开发环境的搭建过程。再描述如何利用龙芯公司的MIPS32 IP核soc_up和已编译好的Linux系统来体验跑一个真实操作系统的过程。然后尝试把自己的一个小汇编程序写到ROM中执行，从而对如何程序在CPU的运行的过程有一个感性的认识。 为了理解自己写CPU的过程，这一章节也会基于2017年龙芯杯比赛中清华队的NaiveMIPS来跑supervisor、U-Boot和ucore这三个逐渐复杂的小系统。 为了理解CPU实现过程中的错误调试方法，最后还会描述如何使用vivado下的Debug IP核ILA。 const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"cpu/Vivado开发环境.html":{"url":"cpu/Vivado开发环境.html","title":"2.1 Vivado开发环境","keywords":"","body":"本节主要介绍Vivado环境的安装配置和Vivado的基本使用 const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"cpu/Vivado环境的安装.html":{"url":"cpu/Vivado环境的安装.html","title":"2.1.1 Vivado环境的安装","keywords":"","body":"一. Ubuntu下的安装 为了开发环境的统一，建议在Ubuntu16.04下安装 1.Ubuntu虚拟机的安装 首先下载Vmware WorkStation软件作为虚拟机运行的环境（需要双系统请自行安装）， 下载Ubuntu16.04的镜像文件ubuntu-16.04.iso。 在Vmware中点击新建虚拟机 点击下一步 添加下载好的Ubuntu镜像文件路径 填写用户名和密码 点击下一步，默认存储路径和虚拟机名称 给虚拟机配置硬盘大小，至少分配50个G，80个G可以保证空间充足 点击下一步至完成即可 等待虚拟即开机。 可以在虚拟机关机状态下进入虚拟机->设置，调节该虚拟机内存，硬盘和共享文件夹等配置 2. Vivado的安装 Vivado压缩包大小为20个G上下，安装包支持win7、10、Ubuntu等系统（64位）。 可以在Windows系统下解后再复制到虚拟机中， 或直接复制到home目录下， 在Ubuntu中使用命令tar -zxvf 压缩文件名.tar.gz解压。 注意：Ubuntu不能随意复制东西到系统盘，建议复制文件到HOME根目录下。 进入到安装包目录中，右键使用Terminal打开。 输入命令chmod -R +x xsetup获取安装权限， 输入命令./xsetup进入安装 软件安装在Home目录下，自己新建的文件夹下 点击next 点击所有Agree 进入版本选择 直接选择WebPack版本，为完全免费版本，虽然有功能的限制，但是完全满足竞赛要求，一共是15个G。 Devices一项，因为龙芯开发板上搭载的是Artix7系列的芯片，勾选上这个型号即可，选择SDK和DocNav。 接下来一路默认就行 安装完成后，可从桌面图标Vivado2018.2进入，或者进入到Vivado bin目录下，用“./vivado”命令打开 二. Ubuntu系统下的安装（方法二） 基于docker的开发环境部署 1.安装docker apt install docker.io 如果出现错误 E:Unable to locate package docker.io 则先执行再安装 sudo apt-get update 2.下载Vivado 2018.1的Docker下镜像（预留至少35GB）（下载链接） ./install-vivado-image.sh 如果出现错误 bash: ./install-vivado-image.sh: Permission denied 则先执行再下载 chmod u+x install-vivado-image.sh 3.编译项目 git clone https://github.com/z4yx/NaiveMIPS-HDL.git cd NaiveMIPS-HDL # building process takes about one hour docker run -ti --rm -v $PWD:/home/vivado/project vivado:2018.1 /opt/Xilinx/Vivado/2018.1/bin/vivado -mode tcl -source xilinx/NaiveMIPS/build.tcl xilinx/NaiveMIPS/PrjVivao.xpr 4.打开界面 sudo docker run -ti --rm -e DISPLAY=$DISPLAY -v /tmp/.X11-unix:/tmp/.X11-unix -v $PWD:/home/vivado/project vivado:2018.1 三. Windows环境下的安装 Windows环境下安装后遇到的问题 1 vivado需要vc2015 redistributable packages，安装完成后第一次打开会要求安装，点击确认即可。 但是如果电脑上安装有vs2017，则会出现不兼容。 解决方法： 2 打开装完后的桌面vivado图标，会弹出Microsoft visual C++2015的一个界面，提示repair或者uinstall，无论点哪个都运行不了，而且之后会有运行超时的提示。 解决方法： 这个情况是C++库的问题，下一个DiretX Repair修复一下，C++redistribution，然后重启即可。 const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"cpu/Vivado的基本使用.html":{"url":"cpu/Vivado的基本使用.html","title":"2.1.2 Vivado的基本使用","keywords":"","body":"一. 新建工程 打开Vivado软件，直接在欢迎界面点击Create New Project 或在开始菜单中选择File - New Project即可新建工程。 点击Next 输入工程名称和路径 选择RTL Project，勾选Do not specify......（这样可以跳过添加源文件的步骤，源文件可以后面再添加） 根据自己的开发板选择器件型号，可以直接通过型号进行搜索，例如龙芯开发板上的芯片型号为Artix-7 AC701。如果不了解或者暂时不写进开发板，可以随便选一个型号，后面需要的时候再修改 点击Finish，项目新建完成 二. 添加Verilog设计文件（Design Source） 在Project Manager窗口中，选择Source子窗口，在空白处或任意文件夹上右击，选择Add Sources，或者点击上面的绿色加号图标 选择Add or Create Design Sources 点击Next。 点击Create File按钮 弹出的小窗口中输入文件名，点击OK。 可以一次性新建或添加多个文件，最后点击Finish。 稍后会弹出定义模块的窗口，也就是刚刚添加的test文件。可以在这里设置test模块的输入输出端口；或者直接点击OK，稍后再自行编写。 点击OK后，如果弹出下面窗口直接点击Yes。 test文件和对应的模块即创建完成，如图 三. 添加Verilog仿真文件（Simulation Source） 操作和上一步添加Verilog设计文件基本一致，唯一的区别是选择Add or Create Simulation Sources。 我们新建一个名为simu的仿真文件。 设计文件新建完成后，在Design Sources和Simulation Sources中都有，而仿真文件只会出现在Simulation Sources文件夹中。设计文件可以用于仿真，也可以用于最终烧写进开发板，而仿真文件仅用于仿真。 四. 编写代码 打开test模块，编写代码实现一个简单的非门电路如下。 module test( input in, output out ); assign out = ~in; endmodule 五. 行为仿真（Behavioral Simulation）与Testbench 为了验证代码是否正确，可以对代码进行行为仿真。我们给上面的test模块输入端in接入一个时钟信号，则输出端out就会产生一个电平相反的时钟信号。 行为仿真时，输入信号可以使用Testbench编写。 如果直接修改test模块，在其中添加Testbench代码，再进行仿真，是一种不太正确的做法。因为test模块是设计文件，后面可能会直接烧写进板子。进行仿真时添加了Testbench代码，之后再烧写进板子又得删掉Testbench代码，这样容易出现错误，而且操作起来也比较麻烦。尤其是接口数量多，内部比较复杂的模块。 所以我们将Testbench代码全部写到仿真文件simu中，并在simu文件中调用test模块，从而进行仿真。 六. 编写仿真代码 在simu模块中编写代码如下。 module simu( ) ; // testbench 时钟信号 reg clk = 0; always #10 clk // 输出信号 wire out; // 调用test模块 test mytest(clk, out); endmodule 代码说明： reg clk = 0声明了一个reg信号，并赋初值为0。 always #10 clk wire out声明了一个wire信号，用于连接到test模块的输出。 test mytest(clk, out)调用了前面写好的test模块，其中mytest是模块名称，这里的clk和out分别连接了mytest模块内部的in和out信号。这种写法类似于面向对象的编程语言中，对象的实例化，test为类名，而mytest为对象名称。同样，Verilog中调用模块时，可以实例化多个test对象。 更多Testbench的写法请上网搜索相关资料。 七. 行为仿真 右击simu模块，选择Set as Top 将simu模块设置为仿真时的顶层模块。顶层模块类似于C编程时的入口函数，即main函数。main函数可以调用其他子函数； 类似的，顶层模块可以调用其他模块。 在Flow Navigator窗口中点击Run Simulation - Run Behavioral Simulation；或者在菜单中选择Flow - Run Simulation - Run Behavioral Simulation，即可启动行为仿真。 稍后Behavioral Simulation窗口打开，即可看到输出的仿真波形。 八. 操作技巧 双击图中右侧的Untitled 2标签，可以最大化仿真波形窗口。在波形窗口按住Ctrl键并滚动鼠标滚轮，可以横向缩放波形； 按住Shift并滚动鼠标滚轮，可以横向平移波形。 如图，可以看出clk为周期20ns的时钟信号，而out和clk的电平始终相反，即test模块中的非门工作正确。 在Behavioral Simulation窗口中的Scopes子窗口，根据模块调用关系选中mytest，在右侧的Objects窗口即可看到test模块中所有的信号（包括内部信号，即没有写到模块声明语句module(a,b,c)括号中的信号）。 右击信号，选择Add To Wave Window，可将波形添加到右侧的仿真波形窗口，保存仿真文件，再次仿真时就可以看到该信号的波形。 对于多位信号例如wire [7:0] p，默认使用二进制形式显示，可以根据需要修改。例如右击选择Radix - Unsigned Decimal即可设置为无符号十进制显示，如图。 const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"cpu/vivado和板子的连接.html":{"url":"cpu/vivado和板子的连接.html","title":"2.1.3 Vivado和实验板的连接","keywords":"","body":"打开hardware manager以后，想要连接板子却始终找不到，按照一下教程安装一下驱动 官方给的解决方案如下： https://www.xilinx.com/support/answers/54381.html 这个方法其实我经过实测是可行的，但是具体的步骤要变，因为对应的目录变了。 我的操作系统是ubuntu 16.04 LTS ，IDE版本是Vivado 2017.1，官方给的方案应该是针对好几个版本以前的，才会出现目录对不上的情况 我的情况是 就像这样auto connect 找不到我的板子，我使用lsusb命令是可以看到我的usb信息的，说明ubuntu知道有这个usb存在，只是因为没有驱动导致跟vivado连不上。 那么我们根据官方的方法来看 Full sudo -s access Run sudo -s Go to/bin/[lin|lin64] or common/bin/[lin|lin64] in an installed area. Copy the install_script directory to /opt. Run \"./install_drivers\" in /opt/install_script/install_drivers. Add windrvr6 read/write access by running \"chmod 666 /dev/windrvr6\". 第一步是进入root账户，对，不进入root是操作不了的。 第二步是进入vivado的安装文件下的bin/[lin | lin64] 啊，对不起，我的bin目录下面没有这个文件夹。 怎么办呢 你看下一条，我们的任务是为了寻找一个叫做 “ install_script ” 的文件夹，所以我们搜一下这个install_script 然后就 找到了它，原来放在的目录不是bin，而是SDK的data。。。 继续第三步，复制到/opt 因为现在是root所以不用sudo，命令如下： cd ~/opt/pkg/vivado/SDK/2016.4/data/xicom/cable_drivers/lin64 cp -i -r install_script /opt 我的vivado安装在 ~/opt/pkg/vivado 你的自己改。因为版本不一样，后面也可能不一样，你也要记得按照你的版本的真实路径来。 然后复制完了，第四步 cd /opt/install_script/install_drivers ./install_drivers 重申，必须是root账户，就是说每一条sh指令前面必须是#而不是@ 到这里可以结束了，反正我可以找到我的板子了，第五步嘛。。。我找不到那个文件夹。。所以也就没法对它chmod了 说真的，我搜了全盘，没有找到名字是 “ wind ” 开头的。 不过能用了，管他呢。 const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"cpu/基于soc_up的移植过程.html":{"url":"cpu/基于soc_up的移植过程.html","title":"2.2 基于soc_up的移植过程","keywords":"","body":"本节主要介绍通过龙芯提供的带TLB功能的cpu soc_up和启动程序pmon，移植ucore操作系统龙芯实验箱的过程及方法 本实验所需工具均位于wiki cpu部分中的第一届大赛资源包 http://os.cs.tsinghua.edu.cn/oscourse/project/LoongsonCsprj2017/bit/cpu 过程如下： (1) 烧写 引导程序PMON 文件（gzrom.bin）到可插拔 SPI flash 上。（具体方法见2.2.1flash的烧录） (2) 下载 由sop_up综合生成的 bit 流文件至龙芯FPGA中。 (3) 运行 PMON。（具体方法见2.2.5pmon启动过程）。 (4) 搭建 tftp 服务器 下载内核至内存。(具体方法见2.2.54TFTP服务器的搭建)。 (5) 启动内核。 const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"cpu/flash烧录方法.html":{"url":"cpu/flash烧录方法.html","title":"2.2.1 Flash的烧录","keywords":"","body":"此方法用于烧写程序至可插拔 flash中 原理 该方法是使用龙芯开源的 gs132 核搭建了一个小的 soc，该 soc 外设有串口、flash 芯片和指令数据 ram,该 soc 在 FPGA 上生成的 bit 流文件可实现通过串口在线编程 flash 芯片, 编程过程中，不需要拔下 flash 芯片，且速率达到 6KB/sec。 实现方法 将目录lab_environment_v1.00\\flash_programmer\\programmer_by_uart 下的programmer_by_uart.bit 文件通过vivado下载至FPGA。 通过串口线将FPGA连接至主机，通过将PMON的二进制文件 （FPGA_test_v1.00\\FPGA_soc_test目录下的gzrom.bin文件）烧录至flash中，其中波特率选为230400，连接正常后，根据提示，键盘输入x表示开始使用xmodem模式传输串口软件使用xmodem模式传输binary文件。等待传输完成,编程过程中，不需要拔下 flash 芯片。 ( ECOM和SecureCRT 软件位于lab_environment_v1.00\\uart_soft，可直接运行与windows环境下，如果过程不成功可以尝试在设备管理器处设置串口的波特率，Linux环境下使用 minicom工具，关于串口工具的使用，可以查看2.2.3串口工具的使用） const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"cpu/FPGA固化方法.html":{"url":"cpu/FPGA固化方法.html","title":"2.2.2 FPGA固化方法","keywords":"","body":"固化的流程：先将一个 bit 流文件转换为 mcs 文件，将 mcs 文件下载到板上一个 SPI flash 上 1. 生成 mcs 文件 首先，需要确保 FPGA 设计的 bit 流文件已经生成。但 bit 流文件是用于直接下载到 FPGA 芯片里的文 件，而不能下载到 flash 芯片里，因而需要转换为 mcs 文件。 在 ISE 工具里，可以再图形界面下点击选择就可生成 mcs 文件，但在 Vivado 工具里，生成 mcs 文件需 要在命令控制器（tcl console）里输入命令。如下图： 上图中蓝色的为输入的命令，pwd 用于查看目录。随后使用 cd 命令进入 bit 流文件所在的目录。 假设生成的 bit 流文件为 project_11.bit，则输入命令串 write_cfgmem -format mcs -interface spix1 -size 16 -loadbit \"up 0 project_11.bit\" -file project_11.mcs 即可生成 mcs 文件，如下图。 其中命串里的 project_11.bit 为待转换的 FPGA 设计的 bit 文件，project_11.mcs 为生成的 mcs 文件名， 可以自定义。 上述命令，是先输入 cd 命令将目录切换到了 bit 流文件的目录，再使用 write_cfgmem 命令将 bit 流文 件转换为 mcs 文件。这两步可以使用命令串 write_cfgmem -format mcs -interface spix1 -size 16 -loadbit \"up 0 F:/vivado_test/project_11/project_11.runs/impl_1/project_11.bit\" -file F:/vivado_test/project_11/project_11.runs/impl_1/project_11.mcs 一步到位。这一命令串中明确指定了 bit 流 文件的目录，和生成的 mcs 文件的保存目录，bit 流文件的目录和文件名必须正确，但 mcs 文件的目录和文 件名可以自定义。 2. 下载 mcs 文件 生成好 mcs 文件后，就需要将其下载到实验板上 SPI flash 上。 像下载 bit 流文件一样，打开 Vivado 工具里的“Open Hardwar Target”，连接设备。 选中 xc7a200t 后，右键选择“Add Configuration Memory Device”，出现如下界面： 在 search 栏 输 入 s25fl128 ， 出 现 两 个 可 选 的 芯 片 型 号 ： s25fl128sxxxxxx0-spi-x1_x2_x4 和 s25fl128sxxxxxx1-spi-x1_x2_x4。具体选择哪个型号的，需要与板上固定的 flash 芯片型号相同（看板上 flash 型号标识的末尾是 0 还是 1）。也可以两者先任选一个，如果后续编程 flash 失败，再回来选另一个型号的。 选好 flash 型号后，点击 OK，弹出如下窗口，询问是否现在编程 flash： 点击 OK，出现编程 flash 的界面： 在 Configuration file 那栏选到 1 小节生成的 mcs 文件，如下图： 点击 OK 即可。后续等待下载 mcs 到 flash 芯片完成即可，如下图： Flash 芯片会先进行擦除，在进行编写，完成后会提示 completed Successfully，如下图： 此时烧写就完成了，需要将实验板断电重新上电，等待一段时间，就可发现固化进实验板的 FPGA 设 备自动加载完成了。 const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"cpu/串口工具的配置和使用.html":{"url":"cpu/串口工具的配置和使用.html","title":"2.2.3 串口工具的使用","keywords":"","body":"Linux系统下minicom的配置使用 Linux系统下，使用minicom实现开发板与主机的交互。 首先输入如下命令安装minicom sudo apt-get install minicom 将 USB 转串口一端连到电脑上，一端连到串口线上，串口线另一端连接到开发板上串口接口上。 在Linux 终端运行，输入命令如下命令开启电脑上的串口界面 sudo minicom -D /dev/ttyUSB0 -D /dev/ttyUSB0 指定串口设备文件 minicom基本操作如下： 1）需使用 Ctrl + a 进入设置状态 2）再接着按 z 进入设置菜单 （1）S键：发送文件到目标系统中； （2）W键：自动卷屏。当显示的内容超过一行之後，自动将後面的内容换行。这个功能在查看内核的啓动信息时很有用。 （3）C键：清除屏幕的显示内容； （4）B键：浏览minicom的历史显示； （5）q键：退出mInicom，会提示确认退出。 *退出minicom: 输入\" q\". 这样会退出minicom. Windows系统下SecureCRT或ECOM串口软件的使用 windows系统下可以使用免安装的 SecureCRT或 ECOM串口软件(发布包目录下 lab_environment/uart_soft)。 先使用 USB 转串口和串口连接线将电脑和开发板相连。 1. SecureCRT 双击程序打开，第一次启动界面如下： 第一行 Protocol 下拉选择 Serial，如下： 其中 Baud rate 为选择波特率，需根据开发板上串口控制器的初始化代码中设置的波特率进行选择(对于 本次校验设备，波特率需选择 57600)。右侧 Flow Control 全不选。Port 的选择需根据 Windows 电脑上的端 口进行选择，可以右键电脑选择设备管理器进入设备管理器查看： 配置好串口后，点击 connect，即可进入串口界面，在波特率设置正确的情况下，可以通过串口与开发板进行交互，如下： 2. ECOM const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"cpu/TFTP服务器的搭建和使用.html":{"url":"cpu/TFTP服务器的搭建和使用.html","title":"2.2.4 TFTP服务器的搭建及使用","keywords":"","body":"1. Linux系统下搭建 (1)安装tftp-server sudo apt-get install tftpd-hpa sudo apt-get install tftp-hpa（如果不需要客户端可以不安装） tftp-hpa是客户端 tftpd-hpa是服务器端 (2)配置TFTP服务器 sudo vim /etc/default/tftpd-hpa 将原来的内容改为: TFTP\\_USERNAME=\"tftp\" TFTP\\_ADDRESS=\"0.0.0.0:69\" TFTP\\_DIRECTORY=\"tftp根目录\" \\#服务器目录,需要设置权限为777,chomd 777 TFTP\\_OPTIONS=\"-l -c -s\" (3)重新启动TFTP服务 sudo service tftpd-hpa restart 2. windows系统下搭建 Windows 下可以使用 tftpd32 软件进行搭建（位于目录 lab_environment_v1.00\\tftp 下）。 (1) 双击打开应用程序 tftpd32： 其中 Current Directory 为 tftp 服务器的根目录，可以点击 Browse 进行更改。点击 Show Dir 可以查看 该根目录下的文件。 Server interfaces 为选择网卡作为 tftp 服务器的网络入口，可以下拉进行选择，示例中选择了有线网卡 接入的 IP：10.90.50.43。 (2) 至此，Windows 上的 tftp 服务器已正常开启了，但局域网里的其他设备还无法访问，需要关闭电脑上 的防火墙。 在控制面板中找到 Windows 防火墙，选择“打开或关闭 Windows 防火墙”: 选择关闭 Windows 防火墙即可。 这样同一局域网上的设备就可通过 tftp://10.90.50.43 访问电脑上搭建的 tftp 服务器了，可以从根目录下载文件，或上传文件到根目录下。 const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"cpu/操作系统的移植.html":{"url":"cpu/操作系统的移植.html","title":"2.2.5 Liunx内核的移植过程","keywords":"","body":"本节以Linux内核为例介绍基于soc_up的操作系统的运行 1. 运行PMON 下载soc_up的bit流至FPGA后，连接上串口，打开串口软件，设置波特率为57600，则可以在串口窗口中看到 PMON 运行信息，运行成功后 则会进入 PMON 提示符，此时可以输入 PMON 命令（具体命令见下面）。 2. 运行操作系统 将编译好的操作系统文件由网口下载至FPGA上的 DDR3 内存上，Linux内核为 目录 FPGA_test_v1.00\\FPGA_soc_test 下的vmlinux。 2.1 最初的内核需要使用网口 加载进入内存执行，因而需要先搭建 Tftp 服务器（具体方法见2.2.4 TFPT服务器的搭建）。 2.2 输入PMON命令ifconfig dmfe0 10.90.50.44则可以给开发板上的网卡配置 IP 为 10.90.50.44（具体需配置的 IP 请查阅同网段的电脑 IP） 2.3 在Ubuntu下的terminal输入如下命令查看主机网卡配置 sudo ip addr 得到网卡配置后，输入如下命令，可以配置主机IP(具体方法参考Ubuntu ip 命令手册) sudo ip addr add 10.90.50.43/24 dev enpS0 /24 代表CIDR，dev enpS0 是指定配置网卡 配置完成后，可以 输入命令 ping 10.90.50.43 用于查看网络是否成功接入。 Linux 在 ping 网络是会一直发 ping 包，可以 Ctrl+C 取消 ping。运行结果如下（红色部分为自己输入的指令）： 假设搭建的 tftp 服务器 IP 为 10.90.50.43，将要下载 Linux 内核（vmlinux，已包含在 lab3 实验包中）放到 tftp 服务器的根目录下，输入PMON 命令load tftp://10.90.50.43/vmlinux即可 load 内核进入 FPGA 上的内存。 输入命令 g console=ttyS0,115200 rdinit=sbin/init即可运行该内核， 命令中 115200，即为串口控制器设置的波特率，设置不对时，串口显示字符为乱码。Linux 内核运行时 波特率为 115200。 当运行 Linux 内核成功后，会出现“Godson2@[~]>”提示符，可以使用常用的 Linux 命令，如上表。 const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"cpu/ram的初始化.html":{"url":"cpu/ram的初始化.html","title":"2.3 ROM的初始化","keywords":"","body":"本节介绍ROM的初始化及其初始化文件的生成过程 const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"cpu/初始化ram的方法.html":{"url":"cpu/初始化ram的方法.html","title":"2.3.1 ROM的初始化过程","keywords":"","body":"1. 添加内核IP 点击Flow Navigator中的IP Catalog，打开窗口添加IP核 搜索 ram模块，出现如下 选择distributed memory generator和block memorygenerator标准： dram和bram差别： 1、bram 的输出须要时钟，dram在给出地址后既可输出数据。 2、bram有较大的存储空间。是fpga定制的ram资源；而dram是逻辑单元拼出来的。浪费LUT资源 3、dram使用更灵活方便些 补充： 在Xilinx Asynchronous FIFO CORE的使用时，有两种RAM可供选择，Block memory和Distributed memory。 区别在于，前者是使用FPGA中的整块双口RAM资源，而后者则是拼凑起FPGA中的查找表形成。 1、较大的存储应用，建议用bram；零星的小ram，一般就用dram。但这仅仅是个一般原则，详细的使用得看整个设计中资源的冗余度和性能要求 2、dram能够是纯组合逻辑，即给出地址立即出数据。也能够加上register变成有时钟的ram。而bram一定是有时钟的。 3、假设要产生大的FIFO或timing要求较高，就用BlockRAM。否则，就能够用Distributed RAM。 Block RAM是比较大块的RAM。即使用了它的一小部分，那么整个Block RAM就不能再用了。 所以。当要用的RAM是小的。时序要求不高的要用Distributed RAM。节省资源。 FPGA中的资源位置是固定的，比如bram就是一列一列分布的。这就可能造成用户逻辑和bram之间的route延时比较长。举个最简单的样例，在大规模FPGA中，假设用光全部的bram。性能通常会下降，甚至出现route不通的情况，就是这个原因。 2. 设置参数 Component Name：生成的IP核模块名 Depth：存储深度，即数据点数目 DataWidth：数据位宽，即每个数据点的位数 Memory Type：ROM，单口RAM，简化的双口RAM（一端读一端写），真双口RAM（两端都可读写） 若选择dram 出现如下 若选择bram 出现如下 3. ROM的初始化 将编写好的程序编译链接生成coe文件（具体实现方法见2.3.2测试程序编译流程）给ROM输入初值，COE文件最后会生成MIF文件用于初始化ROM，若只用于仿真可以仅替换mif文件即可。 const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"cpu/测试程序编译环境及流程介绍.html":{"url":"cpu/测试程序编译环境及流程介绍.html","title":"2.3.2  测试程序编译流程","keywords":"","body":" 1. 编写MIPS架构的汇编文件 文件中包含需要测试的指令 MIPS程序的基本模板如下： # Comment giving name of program and description of function # 说明下程序的目的和作用（其实和高级语言都差不多了） # Template.s #Bare-bones outline of MIPS assembly language program .data # variable declarations follow this line 　　　　 # 数据变量声明 # ... .text # instructions follow this line # 代码段部分 main: # indicates start of code (first instruction to execute) # 主程序 # ... # End of program, leave a blank line afterwards to make SPIM happy 【十分钟教会你汇编】MIPS编程入门（妈妈说标题要高大上，才会有人看>_https://www.cnblogs.com/thoupin/p/4018455.htm 2. 将汇编程序进行编译链接 关于编译相关知识自行学习，可参考博客https://blog.csdn.net/leishangwen/article/details/38228305 2.1 GNU工具链的安装 下载mips-sde-elf-i686-pc-linux-gnu.tar.tar（http://os.cs.tsinghua.edu.cn/oscourse/project/LoongsonCsprj2017/bit/cpu附件），将安装文件复制到Ubuntu的/opt目录下，打开Ubuntu的终端，使用如下命令解压缩。 cd /opt tar vfxj mips-sde-elf-i686-pc-linux-gnu.tar.tar 然后打开用户主目录Home文件夹，在窗口菜单栏中选择View->Show Hidden Files，以显示所有文件，这样可以找到一个隐藏文件.bashrc，在此文件的最后加入 PATH 的设置，如下。 export PATH=”$PATH:/opt/mips-4.3/bin” 重新启动Ubuntu系统。 重启后，打开终端，在其中输入mips-sde-elf-，然后按两次Tab键，会列出刚刚安装的，针对MIPS平台的所有编译工具，表示GNU工具链安装成功。 2.2 使用GNU工具进行编译链接 配置交叉编译环境（具体方法见3.3交叉编译环境'的配置） 下载附件coe_file（http://os.cs.tsinghua.edu.cn/oscourse/project/LoongsonCsprj2019），里面包括了链接器脚本、使用mipsel-linux-gnu-交叉编译环境的makefile和将bin文件转换为coe格式的python程序。 可以直接将新编写的程序直接覆盖inst_rom.S文件的内容，然后输入make命令即可编译生成coe文件。 也可以修改makefile，将脚本中的文件名修改为自己的文件名 const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"cpu/基于NaiveMIPScpu的启动过程.html":{"url":"cpu/基于NaiveMIPScpu的启动过程.html","title":"2.4 基于NaiveMIPS的移植过程","keywords":"","body":"本节介绍基于 Naive MIPS cpu 的系统移植过程，并通过NaiveBootLoader 启动U-boot，supervisor，ucore 1.下载并综合运行生成NaiveMIPS 2.启动U-boot 3.启动supervisor 4.启动ucore const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"cpu/NavieMIPS的综合运行.html":{"url":"cpu/NavieMIPS的综合运行.html","title":"2.4.1 NavieMIPS的综合运行","keywords":"","body":"1. 综合运行 使用如下命令，从GitHub上将Naive MIPS的主分支brd-NSCSCC下载下来(https://github.com/z4yx/NaiveMIPS-HDL) git clone https://github.com/z4yx/NaiveMIPS-HDL 使用vivado打开目录下的NaiveMIPS-HDL-brd-NSCSCC\\xilinx\\NaiveMIPS\\PrjVivao.xpr 工程， 综合运行并生成bit流文件，将bit流文件下载至FPGA中 2. 加载测试 使用NaiveMIPS-HDL-brd-NSCSCC\\utility\\serial_load.py 的python程序测试该cpu。 NaiveMIPS使用NavieBootLoader作为其一级引导程序，已经初始化至cpu的片上内存，故可以直接用 serial_load.py程序通过串口进行交互，其中a该程序用python2编写，需要预先安装 pyserial，pyelftools，tqdm的python库。 进入程序目录，输入如下命令查看程序使用 ./serial_load.py -h 输入如下命令，测试串口线和内存 ./serial_load.py -s /dev/ttyUSB0 -t ram const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"cpu/监控程序的移植过程.html":{"url":"cpu/监控程序的移植过程.html","title":"2.4.2 supervisor的启动过程","keywords":"","body":"supervisor-32： 32位监控程序 移植介绍 使用如下命令下载supervisor的源码 git clone https://github.com/z4yx/supervisor-mips32.git 修改/kernel/kern/init.S 文件 在111行起始处，将原来控制串口可读中断部分代码注释，加入适配MNaive MIPS的关中断程序，之后再加入等待同步的程序。 修改/kernel/kern/kernel.lh文件 将 SerialData 的地址改为 0xBFD03000，SerialStat的地址改为0xBFD03014 修改/kernel/kern/utils.S文件 在15行起始处，修改 截取写状态位 地址为 0x0020 在37行起始处，修改 截取读状态位 地址为 0x0001 修改/term/term.py文件 第30行，将编译环境指定为龙芯编译环境的绝对路径 CCPREFIX = '/opt/gcc-4.3-ls232/bin/mipsel-linux-' 第61行，修改 len(binary) == 16 and binary[ 4 : ] = '\\0' * 12: 说明一下，这里是修改代码段的数据大小。对于龙芯的编译环境，.text的大小是16字节，其中前四个字节是代码数据，后面12个字节是 '\\0'，所以需要判断并提取出来。 至于如何查看.text的大小，可以编一个文本进行格式转换，假如现在已经编译了一个 a.out文件 mipsel-linux-objcopy -j.text a.out -Obinary b 即可查看.text的大小 在kernel目录下，输入如下命令编译程序 make clean make ON_FPGA=y 也可以直接修改makefile文件第19行为 override ON_FPGA ?= y，则可以输入make 编译程序 若编译失败，检测配置的交叉编译环境 在mmakefile第7行处更改 使用介绍 监控程序，能够接受用户命令，支持输入汇编指令并运行，查看寄存器及内存状态等功能。监控程序可在学生实现的 32 位 MIPS CPU 上运行，一方面可以帮助学生理解、掌握 MIPS 指令系统及其软件开发，另一方面可以作为验证学生 CPU 功能正确性的标准。 监控程序分为两个部分，Kernel 和 Term。其中 Kernel 使用 MIPS32 汇编语言编写，运行在实现的 CPU 中，用于管理硬件资源；Term 是上位机程序，使用 Python 语言编写，有基于命令行的用户界面，达到与用户交互的目的。Kernel 和 Term 直接通过串口通信，即用户在 Term 界面中输入的命令、代码经过 Term 处理后，通过串口传输给 Kernel 程序；反过来，Kernel 输出的信息也会通过串口传输到 Term，并展示给用户。 Term Term 程序运行在实验者的电脑上，提供监控程序和人交互的界面。Term 支持7种命令，它们分别是 R：按照$1至$30的顺序返回用户程序寄存器值。 D：显示从指定地址开始的一段内存区域中的数据。 A：用户输入汇编指令，并放置到指定地址上 U：从指定地址读取一定长度的数据，并显示反汇编结果。 G：执行指定地址的用户程序。 T：查看指定的TLB条目。本功能仅在Kernel支持TLB时有效。 Q：退出 Term 利用这些命令，实验者可以输入一段汇编程序，检查数据是否正确写入，并让程序在处理器上运行验证。 启动term.py程序之前，需要进行串口通信同步，打开minicom，看到terminal不断的显示 ...，按下回车，出现\"Monitor initial\"，同步成功。 此时可以启动term.py Term 程序位于`term`文件夹中，可执行文件为`term.py`。运行程序时用 -s 选项指定串口。例如： ./term.py -s /dev/ttyUSB0（串口名称根据实际情况修改） 用户程序编写 根据监控程序设计，用户程序的代码区为0x80100000-0x803FFFFF，实验时需要把用户程序写入这一区域。 用户程序的最后需要以jr $31结束，从而保证正确返回监控程序。 在输入用户程序的过程中，既可以用汇编指令，也可以直接写16进制的机器码。空行表示输入结束。 以下是一次输入用户程序并运行的过程演示： MONITOR for MIPS32 - initialized. >> A >>addr: 0x80100000 one instruction per line, empty line to end. [0x80100000] addiu $2,$0,1 [0x80100004] addu $3,$2,$2 [0x80100008] jr $31 [0x8010000c] nop [0x80100010] >> U >>addr: 0x80100000 >>num: 16 0x80100000: li v0,1 0x80100004: addu v1,v0,v0 0x80100008: jr ra 0x8010000c: nop >> G >>addr: 0x80100000 elapsed time: 0.000s >> R R1 (AT) = 0x00000000 R2 (v0) = 0x00000001 R3 (v1) = 0x00000002 R4 (a0) = 0x00000000 R5 (a1) = 0x00000000 R6 (a2) = 0x00000000 ... 进阶一：中断和异常支持 作为扩展功能之一，Kernel 支持中断方式的I/O，和 Syscall 功能。要启用这一功能，编译时的命令变为： make ON_FPGA=y EN_INT=y 这一编译选项，会使得代码编译时增加宏定义`ENABLE_INT`，从而使能中断相关的代码。 进阶二：TLB支持 在支持异常处理的基础上，可以进一步使能TLB支持，从而实现用户态地址映射。要启用这一功能，编译时的命令变为： make ON_FPGA=y EN_INT=y EN_TLB=y const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"cpu/U-Boot启动过程.html":{"url":"cpu/U-Boot启动过程.html","title":"2.4.3 U-Boot的启动过程","keywords":"","body":" 下载U-Boot源程序并且编译（具体方法见3.3U-Boot的移植过程） 通过使用 NaiveMIPS-HDL-brd-NSCSCC\\utility\\serial_load.py 的python程序直接将U-Boot加载至内存 输入如下命令，将编译的U-Boot程序加载至内存 ./serial_load.py -s /dev/ttyUSB0 -l 文件绝对路径 按下reset键启动U-Boot const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"cpu/ucore的启动过程.html":{"url":"cpu/ucore的启动过程.html","title":"2.4.4 ucore的启动过程","keywords":"","body":" 下载源码并对源码进行移植（具体方法3.5ucore的移植过程） 通过使用 NaiveMIPS-HDL-brd-NSCSCC\\utility\\serial_load.py 的python程序直接将ucore映像加载至内存，输入如下命令： ./serial_load.py -s /dev/ttyUSB0 -l 文件绝对路径 此时是直接使用一级引导程序Naive MIPS启动，而没有涉及U-Boot const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"cpu/ILA的使用.html":{"url":"cpu/ILA的使用.html","title":"2.5 ILA的使用方法","keywords":"","body":"ILA的使用方法 ILA是vivado下的一个DEBUG IP，类似于片上逻辑分析仪，可以实时抓取信号的数值。 在block design中通过+键，输入ILA查找IP核，并将其添加至block design中 双击ILA IP，出现如下界面 Monitor type 如果选择的是AXI，则监控的是整个AXI的信号，此时number of probes 无效 如果选择的是Native，则监控的是单条信号线，number of probes指明监控的信号数 Sample Data Depth 修改抓取信号的采样个数 在probe_portions 一页 probe width 选择各分组信号的位宽 将ILA的输入直接连入需要检测的信号线上，注意AXI也是直接连接到一条AXI线上，不是单独连到AXI adapter 的一个 slave中 重新Generate block design，并综合运行生成bit流文件下板，仿真环境下 ILA并没有意义。 下板后，在vivado中便会出现ILA检测的数据窗口及波形图。 直接点击运行，默认为自动检测触发，每有数据更新便会采样，但是每次采样都会覆盖之前的值。 也可以设置触发条件，当满足触发条件时，ILA采样，此时采样结束后需要重新点击按钮让ILA进入wait状态继续等待触发。 const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"ucore/":{"url":"ucore/","title":"3. MIPS32S CPU上的ucore教学操作系统","keywords":"","body":"MIPS32S CPU上的ucore教学操作系统 参考链接 编译工具链介绍 在ucore的开发与调试中，使用GNU工具链，包括GNU make, GNU Binutils, GCC以及GDB。 GNU make 交叉编译工具链 SoC SoC_up NaiveMIPS (或nscscc) 不同的SoC具有不同的硬件结构，因此编译完成的软件在不同SoC平台上并不通用。 qemu模拟器 QEMU ucore编译过程 编译方法 ucore实现分析 ucore测试用例分析 const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"ucore/make.html":{"url":"ucore/make.html","title":"3.1 make 命令的使用","keywords":"","body":"GNU make make为UNIX系统下的一个工具程序，可以根据预先准备的makefile计算文件间的依赖关系，由源文件生成目标并保证目标的版本不落后与源文件，大量用于软件构建。GNU make为make的一种实现，并在标准之上增加了许多额外功能。 文档 必要知识 Makefile中文件的生成规则由运行环境的命令行解释器执行。在多数UNIX系统上，该解释器为/bin/sh。除此之外，生成中使用到的命令也需要分别指定参数。因此，首先需要对Shell以及所使用的构建工具有基本的了解。 基础 make与makefile Makefile中包括文件间的相互关系，说明了如何使用工具从一个文件生成另一个文件。在目录下执行make命令并不指定makefile时，make将会搜索合适的文件（文件名为makefile或Makefile）并作为makefile读取。因此，一般把它取名为Makefile，置于需构建的项目目录。 make执行时，首先读取makefile，解析其中的规则。若在命令行上指定了构建的目标，make则会尝试生成该目标；否则，make一般会选择文件中的第一个目标进行生成。 通过传给make -j 参数，可以使make同时构建多个目标，加快构建速度。 目标规则 目标规则指定了生成一个文件时所需要的其他文件和所运行的命令。生成规则的一般结构为： target: [prereq...] [ command...] 其中，target为该规则的“目标”，亦即所需要生成的文件名；prereq为生成target的所有依赖，可以为其他目标或文件；command为生成target所要执行的一系列命令（在所有的命令左侧都必须有一个Tab）。 make生成一个目标时，首先会生成它依赖中的所有目标，然后执行命令进行该目标的生成。但若一规则的目标文件存在并且其修改时间晚于任何一个依赖，则该规则未过期，生成该目标时make就会跳过命令执行阶段。生成依赖目标时，make一般会同时进行多个目标的生成。 特殊目标 在makefile中，有一部分特殊的目标并不对应生成的文件，而是用来进行配置。这类目标一般以.开头。 .PHONY：该目标声明其所有依赖均不对应生成的文件 .MAIN：该目标存在时，make将其作为默认目标 .SUFFIXES: 见后缀规则 变量 变量可以出现在makefile的各处。当make遇到变量时，会首先将其展开，然后再继续解析。使用变量的方式为： $(varname)或${varname}。当变量名仅有一个字符时，括号可以省略。 通过设定变量，Makefile可以将重复的内容省略至一处，也可以在运行时通过执行命令确定规则的细节。设定变量的一般方式为： var = value 其中，var为变量名，value为需要设定的值。根据符号mod的不同，var的赋值效果不同。常见的赋值符号有： mod为空，即var = value：以value替换var的值 mod为+，即var += value：在var后附加value mod为?，即var ?= value：若var之前未定义，则以value替换 mod为!，即var != value：将value作为命令执行，然后取其输出替换var的值 在规则中，有一部分变量为预定义： $@：目标的文件名 $*：不含后缀的目标文件名 后缀规则 后缀规则用来定义不同类型文件之间的转换规则，以避免针对每一个文件都要明确制定规则的麻烦。使用后缀规则时，首先需要将需要写入规则的文件类型的后缀列在.SUFFIXES特殊目标的依赖中，例如： .SUFFIXES: .c .o 后缀规则的结构为： sfxrule: [ command...] 其中，sfxrule为转换的两种类型的后缀名的连接，若目标类型无后缀则只用一个类型的后缀。在后缀规则的命令中，可以使用预定义的变量$用来表示该规则的依赖。例如: .c.o: $(CC) $(CCFLAGS) -c -o $@ $ const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"ucore/crosstools.html":{"url":"ucore/crosstools.html","title":"3.2 交叉工具链介绍","keywords":"","body":"Target triplet （目标三元组） 在准备交叉编译工具链时，需要确定目标机器的架构、环境，才能选择出合适的工具链配置。工具链的配置以Target triplet表示。其基本格式为： machine-vendor-os machine代表目标的架构，即目标所使用的CPU类型和配置。需要注意的是，同样的CPU，在不同字节序下工作时所对应的machine并不相同。具体可以参照Installing GCC。常见的machine列表如下： CPU machine 80386 i386 64位PC CPU x86_64或amd64 MIPS32 Big endian mips MIPS32 Little endian mipsel vendor可以用来对工具链的架构进行细节的配置。当不需要深入配置时，可以将其设为unknown或直接省略。在ucore开发中，需要注意的是，如果使用的CPU没有浮点运算指令，vendor需要包括softfloat，避免工具链生成不支持的指令。 os指定目标的操作系统环境，一般包括系统名称以及基础C库名称。该项可以设定工具链的一些默认行为，例如目标文件格式和连接时自动使用的C库等。ucore运行不依赖于外部的软件，因此该项影响不大，可以直接设为常见的linux-gnu，也可以设为ucore-elf。 需要注意的是，对应同样的目标可能有多种不同的Target triplet。在选择具体的工具链时，只需要一种满足需要的即可。例如，在准备对应于MIPS32 Big endian算的ucore工具链时，可以选择如下的Target triplet: mips-softfloat-linux-gnueabi mipsel-linux-gnu (Debian/Ubuntu) 在Debian/Ubuntu下，可以直接执行apt-get install binutils-mipsel-linux-gnu gcc-mipsel-linux-gnu安装需要的工具。 Binutils GNU Binutils包括汇编器、连接器以及许多用来操作目标文件的工具。常用的工具有： 命令 说明 ld GNU连接器 as GNU汇编器 objdump 可以查看目标文件内容、进行反汇编等 objcopy 可以复制、修改目标文件 使用交叉编译工具链时，需要在命令前附加目标的Target triplet，例如，要使用mips-linux-gnu的as，应该使用的命令为mips-linux-gnu-as。 ld GNU连接器，可以根据连接器脚本进行连接。文档 ld连接多个目标文件。作为参数的目标文件的先后顺序对连接结果有影响。 需要生成静态文件时，输入只能包括静态库（.a）或目标文件（.o)。 格式：ld [选项] 目标文件 常用选项： -o 设置输出文件 -L 设置库搜索路径 -l 在库搜索路径中寻找对应的库并加入链接 -T 使用自定义连接器脚本 as GNU汇编器，根据汇编程序产生目标文件。文档 as需要不含预处理的汇编程序（一般以.s作为文件名结尾）。如果需要进行预处理（文件名以.S结尾），可以使用gcc汇编或自行调用cpp预处理。 不同架构的汇编语言有不同的语法。 格式：as [选项] [文件] 当不指定输入文件时，as从标准输入读入源程序。 常用选项： -o 设置输出文件 objdump 显示目标文件信息。文档 格式：objdump [选项] [文件] 当不制定输入文件时，默认使用a.out。 常用选项： -h 查看Section headers。列出目标文件内所有段的信息。 -t 查看符号表。 -x 查看所有区块信息。相当于-a -f -h -p -r -t（Archive信息、文件头、Section headers、文件格式特有的信息、重定位信息、符号表）。 -d 反汇编所有可执行段。该操作会产生相当多的输出，一般应将输出重定向到文件或编辑器。 -j 限定仅处理某个段。 -s 输出段的内容。一般与-j连用。 objcopy 修改目标文件。文档 格式：objcopy [选项] [输出] 若不指定输出文件，将会直接删除输入文件并使用输入的文件名。 常用选项： -I 指定输入格式 -O 指定输出格式 -j 限定仅处理某个段 常见用法： 提取.text段： $ objcopy -Obinary -j .text bootsect.elf bootsect.mbr 该命令从bootsect.elf中提取.text段（代码段），存入bootsect.mbr，对段的内容不进行改动。 GCC GCC(GNU Compiler Collection)包括一系列编程语言的编译器以及语言的底层库。在ucore的开发中，仅使用其C编译器(gcc)。 与Binutils相同，使用交叉编译工具链时，需要在命令前附加目标的Target triplet。要使用mips-linux-gnu的gcc，应该使用的命令为mips-linux-gnu-gcc。 gcc GCC的C编译器。一般用来编译C程序，也可以进行连接或汇编带预处理的汇编语言。GCC所支持的选项根据不同版本有所不同。 格式：gcc [选项] 输入 常用选项： -o 指定输出文件名 -c 仅进行编译而不连接 -I 设定预处理include搜索路径 -Wall 开启大部分警告 -std= 设定C语言标准 -ffreestanding 设定运行环境为freestanding，即无标准库 常见用法： 编译程序至目标文件： $ gcc -std=c99 -I ../include -Wall -c -o mm.o mm.c 该命令编译mm.c，在../include以及系统头文件中搜索#include所引用的头文件，并且对大多数可能存在问题的地方提出警告，最终将结果输出至mm.o。 const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"ucore/交叉编译环境配置.html":{"url":"ucore/交叉编译环境配置.html","title":"3.3 交叉编译环境的配置","keywords":"","body":"1. mips-sde-elf-交叉编译环境的配置 该交叉编译工具较老，有些同学的电脑可能会配置不成功，也可以配置mipsel-linux-gnu- 下载mips-sde-elf-i686-pc-linux-gnu.tar.tar（http://os.cs.tsinghua.edu.cn/oscourse/project/LoongsonCsprj2017/bit/cpu 附件），将安装文件复制到Ubuntu的/opt目录下，打开Ubuntu的终端，使用如下命令解压缩。 cd /opt tar vfxj mips-sde-elf-i686-pc-linux-gnu.tar.tar 然后打开用户主目录Home文件夹，在窗口菜单栏中选择View->Show Hidden Files，以显示所有文件，这样可以找到一个隐藏文件.bashrc，在此文件的最后加入 PATH 的设置，如下。 export PATH=”$PATH:/opt/mips-4.3/bin” 重新启动Ubuntu系统。 重启后，打开终端，在其中输入mips-sde-elf-，然后按两次Tab键，会列出刚刚安装的，针对MIPS平台的所有编译工具，表示GNU工具链安装成功。 2. mipsel-linux-gnu-交叉编译环境的配置 需要配置mips下的交叉编译环境，使用了 Ubuntu 16.04 操作系统提供的软件包“gcc-mipsel-linux-gnu”和“binutils-mipsel-linux-gnu”。 输入以下命令进行安装： sudo apt-get install gcc-mipsel-linux-gnu binutils-mipsel-linux-gnu 此外还要安装 dtc（设备树编译器） sudo apt install device-tree-compiler const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"ucore/U-Boot移植过程.html":{"url":"ucore/U-Boot移植过程.html","title":"3.4 U-Boot的移植过程","keywords":"","body":"1. U-boot源码下载 https://github.com/z4yx/u-boot-naivemips.git 该源码可以直接编译，只需配置环境即可 2. U-Boot介绍 U-Boot 是一个启动引导程序， 常见于嵌入式系统中， 用于引导 Linux 等操作系统。 在基于 NaiveMIPS 的 SoC 上，运行 U-Boot 引导程序，支持从 Flash、网络等来源加载 Linux、uCore 系 统镜像并引导。 在NaiveMIPS移植实验中，我们以U-Boot 作为二级引导程序，放置在外部存储设备中。CPU 复位后首先执行一 级引导程序（NaiveBootloader，转换为coe文件初始到NaiveMIPS RAM IP核中），一级引导程序将 U-Boot 复制到内存后，跳转到 U-Boot 入口地 址，U-Boot 开始运行。 3. 源码说明 该源码以U-Boot 2017.7 版本作为基础，添加 NaiveMIPS 平台和板级支持代码实现兼容，所有改动都已经完成。 添加 SoC 平台 在源码树的 arch/mips 下面是整个 MIPS 平台的支持代码，我们需要向其中添加一款新的芯片， 即 NaiveMIPS。这主要涉及到修改或添加几个文件。 arch/mips/Kconfig 文件 添加 MACH_NAIVEMIPS 选项，描述平台的基本特征 arch/mips/Makefile 文件 针对 NaiveMIPS 平台的特定编译选项 arch/mips/mach-naivemips/Kconfig 文件 NaiveMIPS 支持的电路板列表 NaiveMIPS 处理器与 MIPS32 Release1 规范最接近，因此在 MACH_NAIVEMIPS 选项 中 select SUPPORTS_CPU_MIPS32_R1，从而复用 U-Boot 中对于该规范已有的实现代码。 同时由于指令实现上的差异，在编译选项中，针对本平台添加代码 -mno-branch-likely 和-mdivide-breaks， 这是为了避免产生未实现的 Branch Likely 和 TEQ 指令。 添加板级描述 在新的 SoC 平台基础上进一步增加使用该平台的电路板描述和外设驱动描述。以大赛实验箱平台 为例，该步骤主要涉及到修改或添加几个文件。 arch/mips/mach-naivemips/Kconfig 文件 平台支持的电路板列表中添加 TARGET_NAIVEMIPS_NSCSCC board/nscscc/Kconfig 文件 实验板的基本信息描述 board/nscscc/FPGA-A7/ 文件 新建实验板的代码目录 board/nscscc/FPGA-A7/Makefile 文件 实验板的代码编译控制文件 board/nscscc/FPGA-A7/naivemips_nscscc.c 文件 实验板初始化代码 arch/mips/dts/naivemips_nscscc.dts 文件 实验板设备树文件 include/configs/naivemips_nscscc.h 文件 实验板配置类宏定义 configs/naivemips_nscscc_defconfig 文件 实验板默认配置 当用户在构建时，通过 menuconfig 工具选择实验板时，board/nscscc/FPGA-A7/目录下面 相关的代码将被编译，成为板级支持代码，负责电路板相关的初始化工作（如探测内存大小）。由 于实验板比较简单，初始化函数基本为留空。 dts 设备树文件和 include/configs/naivemips_nscscc.h 头文件中的宏定义，共同提供了电 路板具体的硬件信息。这些信息包括外设的型号、地址映射、中断连接及存储空间等。头文件中还 包含默认的 U-Boot 环境变量，利用这些环境变量可以实现自动启动等功能，避免每次上电都要求 用户手工输入启动命令。 由于 U-Boot 具有高度的可裁剪性，内部大多数功能模块都可以在构建时通过 menuconfig 工 具进行选择。最适合龙芯实验板的选项保存到configs/naivemips_nscscc_defconfig 中， 故编译时无需再对源码或者配置文件做任何修改，便于新用户快速完成构建工作。 4. 编译环境配置 需要配置mips下的交叉编译环境，使用了 Ubuntu 16.04 操作系统提供的软件包“gcc-mipsel-linux-gnu”和“binutils-mipsel-linux-gnu”。 输入以下命令进行安装： sudo apt-get install gcc-mipsel-linux-gnu binutils-mipsel-linux-gnu 此外还要安装 dtc（设备树编译器） sudo apt install device-tree-compiler 5. 编译U-Boot 进入顶层目录，用如下命令选择默认的构建配置选项并构建 U-Boot。 make CROSS_COMPILE=mipsel-linux-gnu- naivemips_nscscc_defconfig make CROSS_COMPILE=mipsel-linux-gnu- 在构建成功完成后，顶层目录中会生成 u-boot 文件，即为 ELF 格式的 U-Boot 程序，该文件 可以由 NaiveBootloader 运行。 const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"ucore/qemu.html":{"url":"ucore/qemu.html","title":"3.5 QEMU介绍","keywords":"","body":"QEMU 主页 QEMU可以用来模拟MIPS系统。通过修改其源代码可以模拟真实的硬件平台，并且配合GDB可以对操作系统进行除错。 编译 为使用QEMU模拟特殊的硬件平台，需要自行进行配置及编译。 获取源代码 从QEMU主页可以找到下载。 修改源代码添加硬件平台 根据SoC_up介绍的结构以及地址空间分配，添加新的硬件平台。 Patch文件 进行编译 准备一个编译文件夹，在其中执行源码目录下的configure进行配置，并根据情况关闭不需要的功能。模拟SoC_up所需要的target为mipsel-softmmu。 配置完成后，执行make即可进行编译。编译完成的模拟器位于mipsel-softmmu/qemu-system-mipsel。 运行使用 具体的使用说明可以参考QEMU的文档。需要模拟SoC_up时，可使用如下的参数启动： $ ./mipsel-softmmu/qemu-system-mipsel -machine soc_up -serial stdio -kernel ../ucore-thumips/flash.img 配合GDB除错 QEMU的-s选项可以开启GDB的除错接口。如果需要在启动时暂停CPU，可以加上-S选项。 GDB可以使用target remote :命令连接GDB。 const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"ucore/os_comp.html":{"url":"ucore/os_comp.html","title":"3.6 ucore编译方法","keywords":"","body":"ucore 编译方法 编译 SoC_up 上的 ucore 获取源码 源码位于https://github.com/z4yx/ucore-thumips的for-ls232-soc_up分支下。 根据环境修改编译选项 由于编译环境不同，需要在Makefile中更正选项。修改的选项有： GCCPREFIX 将 GCCPREFIX 修改为适合交叉编译环境的值。如果使用的是Debian/Ubuntu系统提供的工具链，可以将其改为mipsel-linux-gnu-。 CFLAGS 向CFLAGS添加选项： -fno-builtin-fprintf 源代码中的部分函数与C标准库函数名称重合。GCC可能将这些函数优化为其他未实现的C库函数。若编译失败应检查是否有其他函数出现类似的现象。 -fno-pic -mno-abicalls -mno-shared MIPS的ABI要求gp寄存器的值必须有效，导致内核以及用户态进程在初始化时因gp无效而出错。 汇编器选项： Makefile中没有为汇编器设置参数方便调整，需要找到这些部分并添加-fno-pic -mno-abicalls -mno-shared。 Patch文件 编译 在源代码目录执行make即可编译。flash.img即指向编译结果。 const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"ucore/龙芯编译环境配置.html":{"url":"ucore/龙芯编译环境配置.html","title":"3.7 龙芯编译环境配置","keywords":"","body":"龙芯编译环境的配置 1.下载龙芯提供的编译环境配置压缩包gcc-4.3-ls232.tar.gz（http://os.cs.tsinghua.edu.cn/oscourse/project/LoongsonCsprj2018） 2.输入如下指令，将其加压至根目录 sudo tar -zxvf gcc-4.3-ls232.tar.gz -C / 3.打开home目录下的bashrc文件添加路径（没找着的话就在edit处将 show hidden file开启）找到export PATH = $PATH 这行，如果没有就在文件尾部新建 在末尾加上 gcc-4.3-ls232的路径，即 :/opt/gcc-4.3-ls232/bin 也可以通过命令添加路径 echo \"export PATH=/opt/gcc-4.3-ls232/bin:$PATH\" >> ~/.bashrc 4.对于64位系统还需要安装lsb-core，输入如下指令 sudo apt-get install lsb-core 完成上述工作后如果可以输入 mipsel-linux-gcc -v 命令，如果可以正确查看版本号则说明配置正确，编写一个test.s文件，使用如下命令编译mispel-linux-as test.s，得到a.out，mipsel-linux-objdump -d a.out 反编译，若上述步骤都走通，则编译环境配置成功。 对于lsb-core，如果安装失败。 输入如下指令 sudo dpkg --add-architecture i386 sudo apt-get update sudo apt-get -f install lsb-core const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"compiler/":{"url":"compiler/","title":"4. MIPS32S上的C0编译器实验","keywords":"","body":"MIPS32S上的C0编译器实验 参考链接 编译器生成工具介绍 SPIM模拟器介绍 C0编译器的生成过程 C0编译器分析 词法分析 语法分析 代码生成 在ucore上运行C0编译器生成的可执行文件 const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "},"integration/":{"url":"integration/","title":"系统集成","keywords":"","body":"系统集成 在仿真环境下测试ucore的执行 在FPGA开发板上测试ucore的执行 在qemu模拟器上ucore中测试C0编译器生成的应用程序 在FPGA开发板上ucore中测试C0编译器生成的应用程序 const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitalk.render('gitalk-container') require(['gitbook'], function(gitbook) { const gitalk = new Gitalk({ clientID: 'feb1d5080990202eabaa', clientSecret: 'acca204c0fa589a78eff7878c9d41096921001b3', repo: 'LoongsonCsprj2020', owner: 'oscourse-tsinghua', admin: ['xyongcn'], createIssueManually: true, id: document.title }) gitbook.events.bind('page.change', initMygitalk) function initMygitalk() { gitalk.render('gitalk-container') } }) "}}